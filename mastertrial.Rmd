---
title: "mastertrial"
author: "Mingkun Wu"
date: "11/26/2020"
output: html_document
---

```{r}
install.packages("remotes")
remotes::install_github("STATS-UOA/UOARmdTemplates")
```


```{r}
Sys.setenv(LANG = "en")
install.packages("listdown",repo="https://cran.stat.auckland.ac.nz")
```
# Introduction draft
R markdown allows authors to embed objects into reproducible documents, this eases the layout of a document or report with multiple type of objects without extensive combination later when processing. This is achieved by implanting R codes within lines of text where needed. For example, a report usually consists of data processing, cleaning/transformation, analysis, table-making, and visualization. Each one of the step returns with different outputs such as tables, models, graphs _etc._. These objects are named as _computational components_ from here onward since they are generated by computational means. 

The __Rlistdown__ package highly integrates a bundle of computational components into a list of objects. However, when it comes to visualization components (ie. trelliscope), the plot is fixed to a specific given data. Our goal is to make it live and interactive. That is, when the author inputs different data, the plot changes correspondingly. 

#2BasicOverview

Lets suppose the data analyzing part of work is completed, results of the analysis contains summary tables, data tables, plots etc. Each one of the objects are stored as a list of which will be presented in order in a document like html.

The data Anscombe Quartet is used in this example. Four scatter plot was saved as the markdown file named _computational components_, we can see the class of the object _comp_ is a list. 
```{r}
library(ggplot2)

 # Load the Anscombe Quartet.
 data(anscombe)
 
# Create the ggplot objects to display.
 computational_components <- list(
 Linear = ggplot(anscombe, aes(x = x1, y = y1)) + geom_point(),
 `Non Linear` = ggplot(anscombe, aes(x = x2, y = y2)) + geom_point(),
 `Outlier Vertical`= ggplot(anscombe, aes(x = x3, y = y3)) +
 geom_point(),
 `Outlier Horizontal` = ggplot(anscombe, aes(x = x4, y = y4)) +
 geom_point())

 # Save the file to disk to be read by the output R Markdown document.
 saveRDS(computational_components, "comp-comp.rds")
 
comp <- readRDS("comp-comp.rds")
class(comp)

```

Now we load in the listdown package to make a document. We define how the list of objects will be loaded into R, along with the library required to do so. The header for the markdown file is also embedded, shown in the example named _doc_. 
```{r}
library(listdown)

ld <- listdown(load_cc_expr = readRDS("comp-comp.rds"),
package = "ggplot2")

anscombeexample <- c(
 as.character(ld_rmarkdown_header("Anscombe's Quartet",
author = "Francis Anscombe",
 date = "1973")),
ld_make_chunks(ld))

anscombeexample
```

```{r}
# Write the document.
writeLines(anscombeexample, "anscome-example.rmd")
render("anscome-example.rmd",html_document())
system("open anscome-example.html")
```


#MoreComplicated example
In the previous example, the _ggplot_ contains both the plotting mechanism for the scatter plots and the actual plots stored as list type objects. In the following example, we have used another set of data from the _survminer_ package. The original data was added into the document, and are presented in the form of data tables, that is, a type of decorator for the data. 

The _rld_ function shows a general syntax for rendering a listdown file into a html document. The header like the previous example can be added seperately. 
```{r}
rld <- function(ld) {
  writeLines(ld_make_chunks(ld), "doc.Rmd")
  render("doc.Rmd",html_document())
  system("open doc.html")
}
```

The 

```{r}
#survival example:
library(listdown)
library(gtsummary)
library(dplyr)
library(survival)
library(survminer)
library(rmarkdown)
library(plotly)
make_surv_cc <- function(trial, treat, surv_cond_chars) {
  table_1 <- trial %>%
    tbl_summary(by = all_of(treat))  %>%
    gtsummary::as_flextable()
  scs <- lapply(c("1", surv_cond_chars),
                function(sc) {
                  sprintf("Surv(ttdeath, death) ~ %s + %s", treat, sc) %>%
                    as.formula() %>%
                    surv_fit(trial) %>%
                    ggsurvplot()
                })
  
  
  #I didn't quite understand this chunk and the next chunk of codes ( lines 98 - 132 ). 
 
  
  
  
  names(scs) <- c("Overall", tools::toTitleCase(surv_cond_chars))
  list(`Table 1` = table_1, `Survival Plots` = scs, test = plot_ly(z=volcano, type="surface"))
}
surv_cc <- make_surv_cc(trial, treat = "trt",
                        surv_cond_chars = c("stage", "grade"))
ld_cc_dendro(surv_cc)
saveRDS(surv_cc, "surv-cc.rds")
ld_surv <- listdown(load_cc_expr = readRDS("surv-cc.rds"),
                    package = c("gtsummary", "flextable", "DT", 
                                "ggplot2", "plotly"),
                    decorator_chunk_opts = 
                      list(gg = list(fig.width = 8,
                                     fig.height = 6)),
                    decorator = list(data.frame = datatable),
                    echo = FALSE,
                    message = FALSE,
                    warning = FALSE,
                    fig.width = 7,
                    fig.height = 4.5)
rld(ld_surv)


```
#trelliscopejs example
The decorators has displayed the data despite the huge amount of data in the actual dataset. 

Now, by using trelliscopejs package, we are trying to fit multiple interactive plots in the listdown files as objects, further displaying after rendering into html. The following example shows how trelliscope works in R. 

We have used the data from package _gapminder_. There are 5 continents, and we plotted the Oceania one.
```{r}
library(ggplot2)
library(gapminder)
head(gapminder)
str(gapminder)
summary(gapminder$continent)
```



```{r}
#just oceania 
qplot(year, lifeExp, data = subset(gapminder, continent == "Oceania")) +
  facet_wrap(~ country + continent) + theme_bw()
```

Too much plots if we plot it stright away, the final layout is folded, hence the trelliscopejs package allows us to search plots via interactive interface. 
```{r}
qplot(year, lifeExp, data = gapminder) +
  xlim(1948, 2011) + ylim(10, 95) + theme_bw() +
  facet_wrap(~ country + continent)

#trelliscope instead of facet
library(trelliscopejs)
qplot(year, lifeExp, data = gapminder) +
  xlim(1948, 2011) + ylim(10, 95) + theme_bw() +
  facet_trelliscope(~ country + continent, nrow = 2, ncol = 7, width = 300)

```


same survminer data try using plotly
```{r}
yrlfexp <- gapminder[sample(nrow(gapminder), 500), ]
plot_ly(yrlfexp, x = yrlfexp$year, y = yrlfexp$lifeExp, 
        text = paste("continent: ", yrlfexp$continent),
        mode = "markers", color = yrlfexp$country, 
        size = yrlfexp$lifeExp)
```




#for fun
```{r}
library(networkD3)
data(MisLinks, MisNodes)
forceNetwork(Links = MisLinks, Nodes = MisNodes, Source = "source",
             Target = "target", Value = "value", NodeID = "name",
             Group = "group", opacity = 0.4)


```

















