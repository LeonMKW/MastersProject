---
title: "mastertrial"
author: "Mingkun Wu"
date: "11/26/2020"
output: html_document
---




```{r}
Sys.setenv(LANG = "en")
library(listdown)
library(ggplot2)
library(gtsummary)
library(dplyr)
library(survival)
library(survminer)
library(rmarkdown)
library(plotly)
library(gapminder)
library(trelliscopejs)
library(DT)
```



# Abstract {-}

Statisticians and analysts have been using R for a long time. R programming environment has reproducible document standards embedded, such as R markdown. While R markdown requires the programmer to manually construct the structure of reproducible file, R list-down Package provides a programmatic solution to generate the files. On top of the already available R list down package, this paper demonstrates implanting graphs and interactive plots when users generate any reproducible documents by using ```trelliscopejs package```. The concept is followed by a demonstration using gapminder dataset. 
\newpage




# Introduction draft
R markdown allows authors to embed objects into reproducible documents, this eases the layout of a document or report with multiple type of objects without extensive combination later when processing. This is achieved by implanting R codes within lines of text where needed. For example, a report usually consists of data processing, cleaning/transformation, analysis, table-making, and visualization. Each one of the step returns with different outputs such as tables, models, graphs _etc._. These objects are named as _computational components_ from here onward since they are generated by computational means. 

The __Rlistdown__ package highly integrates a bundle of computational components into a list of objects. However, when it comes to visualization components (ie. trelliscope), the plot is fixed to a specific given data. Our goal is to make it live and interactive. That is, when the author inputs different data, the plot changes correspondingly. 




```{css, echo = FALSE}
<center> <h1>2 Background</h1> </center>
```


Lets suppose the data analyzing part and all coding work has completed. The results of the analysis containing summary tables, data tables and plots which we referred to computational components, are collected into a list of objects. They are roughly in the order of which we would like to present them, the next thing is to present the components in a document like html. This is a typical order of a data analyzing work processes, but it is not definite. 

Sometimes, the computational components along with the results they produce are stored in multiple locations, or in many cases, on different machines. It is particularly important to centralize them. There are many advantages turning them in lists. Firstly, turning them into list of elements naturally provides a hierarchical structure for centralizing. Secondly, for most data, even on large scales, the actual presented contents are relatively small. Storing them into lists allows easier access and aligns with the concepts of centering. Last but not least, if the elements in the list are not in the order of a presentation desired, or changes accordingly, manipulating the order is much more convenient than non-centralized components.  

The data Anscombe Quartet from the __datasets__ package( R Core Team 2012) is used in this first example. Four scatter plot produced using __ggplot2__ was saved in the markdown file named _computational components_ as lists. They are named "Linear", "Non Linear", "Outlier Vertical" and " Outlier Horizontal", each contains their corresponding graphics. We can see the class of the R object _comp_ is a list. 
```{r}
library(ggplot2)

 # Load the Anscombe Quartet.
 data(anscombe)
 
# Create the ggplot objects to display.
 computational_components <- list(
 Linear = ggplot(anscombe, aes(x = x1, y = y1)) + geom_point(),
 `Non Linear` = ggplot(anscombe, aes(x = x2, y = y2)) + geom_point(),
 `Outlier Vertical`= ggplot(anscombe, aes(x = x3, y = y3)) +
 geom_point(),
 `Outlier Horizontal` = ggplot(anscombe, aes(x = x4, y = y4)) +
 geom_point())

 # Save the file to disk to be read by the output R Markdown document.
 saveRDS(computational_components, "comp-comp.rds")
 
comp <- readRDS("comp-comp.rds")
class(comp)

```


## 2.1 Creating the document using Package Listdown

The list containing the plots is now saved as a R object named _comp-comp.rds_. From here, the document goes through the following steps: A ```listdown``` object will be created. The object will be loaded into the designated document with a specified way, along with the libraries and codes required for the computational component. Then deciding how the elements in the list will be presented in the document. 

Now we load in the listdown package to make a document. We define how the list of objects will be loaded into R. The header for the markdown file is also embedded, shown in the example named _doc_. 

```{r}
library(listdown)

ld <- listdown(load_cc_expr = readRDS("comp-comp.rds"),
package = "ggplot2")
```




```{r}
anscombeexample <- c(
 as.character(ld_rmarkdown_header("Anscombe's Quartet",
author = "Francis Anscombe",
 date = "1973")),
ld_make_chunks(ld))

anscombeexample
```

```{r}
# Write the document.
writeLines(anscombeexample, "anscome-example.rmd")
render("anscome-example.rmd",html_document())
system("open anscome-example.html")
```







#MoreComplicated example
In the previous example, the _ggplot_ contains both the plotting mechanism for the scatter plots and the actual plots stored as list type objects. In the following example, we have used another set of data from the _survminer_ package. The original data was added into the document, and are presented in the form of data tables, that is, a type of decorator for the data. 

The _rld_ function shows a general syntax for rendering a listdown file into a html document. The header like the previous example can be added seperately. 
```{r}
rld <- function(ld) {
  writeLines(ld_make_chunks(ld), "doc.Rmd")
  render("doc.Rmd",html_document())
  system("open doc.html")
}
```

The 

```{r}
#survival example:
library(listdown)
library(gtsummary)
library(dplyr)
library(survival)
library(survminer)
library(rmarkdown)
library(plotly)
library(ggplot2)
library(DT)

make_surv_cc <- function(trial, treat, surv_cond_chars) {
  table_1 <- trial %>%
    tbl_summary(by = all_of(treat))  %>%
    gtsummary::as_flextable()
  scs <- lapply(c("1", surv_cond_chars),
                function(sc) {
                  sprintf("Surv(ttdeath, death) ~ %s + %s", treat, sc) %>%
                    as.formula() %>%
                    surv_fit(trial) %>%
                    ggsurvplot()
                })
  
  

  
  
  names(scs) <- c("Overall", tools::toTitleCase(surv_cond_chars))
  list(`Table 1` = table_1, `Survival Plots` = scs, test = plot_ly(z=volcano, type="surface"))
}
surv_cc <- make_surv_cc(trial, treat = "trt",
                        surv_cond_chars = c("stage", "grade"))
ld_cc_dendro(surv_cc)
saveRDS(surv_cc, "surv-cc.rds")
ld_surv <- listdown(load_cc_expr = readRDS("surv-cc.rds"),
                    package = c("gtsummary", "flextable", "DT", 
                                "ggplot2", "plotly"),
                    decorator_chunk_opts = 
                      list(gg = list(fig.width = 8,
                                     fig.height = 6)),
                    decorator = list(data.frame = datatable),
                    echo = FALSE,
                    message = FALSE,
                    warning = FALSE,
                    fig.width = 7,
                    fig.height = 4.5)
rld(ld_surv)


```
#trelliscopejs example
The decorators has displayed the data despite the huge amount of data in the actual dataset. 

Now, by using trelliscopejs package, we are trying to fit multiple interactive plots in the listdown files as objects, further displaying after rendering into html. The following example shows how trelliscope works in R. 

We have used the data from package _gapminder_. There are 5 continents, and we plotted the Oceania one.
```{r}
library(ggplot2)
library(gapminder)
head(gapminder)
str(gapminder)
summary(gapminder$continent)
```



```{r}
#just oceania 
qplot(year, lifeExp, data = subset(gapminder, continent == "Oceania")) +
  facet_wrap(~ country + continent) + theme_bw()
```

Too much plots if we plot it stright away, the final layout is folded, hence the trelliscopejs package allows us to search plots via interactive interface. 
```{r}
qplot(year, lifeExp, data = gapminder) +
  xlim(1948, 2011) + ylim(10, 95) + theme_bw() +
  facet_wrap(~ country + continent)

#trelliscope instead of facet
library(trelliscopejs)
qplot(year, lifeExp, data = gapminder) +
  xlim(1948, 2011) + ylim(10, 95) + theme_bw() +
  facet_trelliscope(~ country + continent, nrow = 2, ncol = 7, width = 300)

```


same survminer data try using plotly
```{r}
yrlfexp <- gapminder[sample(nrow(gapminder), 500), ]
plot_ly(yrlfexp, x = yrlfexp$year, y = yrlfexp$lifeExp, 
        text = paste("continent: ", yrlfexp$continent),
        mode = "markers", color = yrlfexp$country, 
        size = yrlfexp$lifeExp)
```




#for fun
```{r}
library(networkD3)
data(MisLinks, MisNodes)
forceNetwork(Links = MisLinks, Nodes = MisNodes, Source = "source",
             Target = "target", Value = "value", NodeID = "name",
             Group = "group", opacity = 0.4)


```

















