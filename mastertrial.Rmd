---
title: "mastertrial"
author: "Mingkun Wu"
date: "11/26/2020"
output:
  html_document: default
  pdf_document: default
---

```{r libraries, include = FALSE, echo=FALSE, warning=FALSE,message=FALSE}
Sys.setenv(LANG = "en")
library(listdown)
library(ggplot2)
library(gtsummary)
library(flextable)
library(dplyr)
library(rmarkdown)
library(plotly)
library(gapminder)
library(trelliscopejs)
library(DT)
library(knitr)
```



# Abstract 

Statisticians and analysts have been using R for a long time. R programming environment has reproducible document standards embedded, such as R markdown. While R markdown generate documents itself programmatically, it requires the programmer to manually construct the structure of a file as a whole reproducible document. For the majority of work done as prose contents, often accompanied with narrative explanations and contexts, the ```listdown``` Package available on the Comprehensive R Archive Network (CRAN) provides a programmatic solution to generate documents containing computational and narrative components efficiently, including tasks with visualizations. This paper demonstrates multiple methods to implant interactive plots and graphics to a document when users generate reproducible documents using the listdown Package. These methods are supported by the ```plotly``` and ```trelliscopeJS``` packages available on CRAN. The concepts are illustrated using the gapminder dataset from the ```gapminder``` package, and will be applied to a current analytical task on COVID-19 data sourced from the World Health Organisation. 

Keywords: reproducible documents, effective visualizations, big data visualizations

# CH1 Introduction

## 1.1 R markdown 

The R markdown (Baumer, Cetinkaya-Rundel, Bray, Loi, and Horton, 2014) demonstrates the possibility of constructing reproducible documents using R language. The format allows author to integrate R codes, written work, data tables, visualization plots and much more information into one directly structured document. Among scientific writings and analytical reports knitted using R markdown, the majority are made up of codes and narrative writings. The codes are usually but not limited to common computing languages, such as R, Python, SQL and others. The writings which contextualize the codes usually follow the codes. Sometimes descriptive writings are also placed between the codes using a hash, and is usually comments of the code lines. In this paper, the chunk of computing codes that produces outputs and the narrative writings that describes the outputs will be referred to computational components and narrative components respectively (Kane,Jiang and Urbanek, 2020). 

Statistical analysis tends to be more reachable and interpretable to public audience accompanied by the rapid rise of computing abilities. While the statistical computing threshold lowers with the invention of R language, the needs to integrate computationally derived objects with narrative explanations arise. The usage of R markdown centralizes different data types with a specific format, further process with the technical work in a computationally organized way. Usually in most data analyzing tasks, the first thing is data cleaning and tidying. However, this processes usually requires other environments and configuration to manipulate. Such steps have different needs in computational purpose than report or presentations. It may not become fully shown using R code or other languages natively supported by R, but authors often use narrative texts to describe the associate processes. These narrative texts can be fully embedded in the R markdown file for readers to follow without opening other documents. Before a highly informative presentation, multiple explanatory analyses are often carried out. These explanatory analyses contain numerous amounts of table, plots and graphs, most of them have comments and notes. R markdown can save the robust components and generate documents without spending time on layouts and formats. 

The advantage of R markdown’s narrative feature can be shown in multiple prospects. Firstly, R markdown is as described in its name, a Markdown syntaxed mark-up language of R. By using combinations of codes and embedding symbols to control the formatting and layout of a R object file, users gets the desired final output document. All of these are easy to achieve without extensive skills in coding and consumes less time and effort to learn. Packages such as bookdown (Xie, 2016) demonstrates the easiness for users indenting to edit long narrative components in contrast of using another commonly-used markup language – Latex. While latex may be more expressive in terms of proficiency in terms of academical writing, the coding alike syntax required to produce documents takes a substantial amount of time and effort to learn and is relatively more complicated than R markdown’s syntax. On the other hand, statistical reports and presentations often contains numerous computational and narrative components. R markdown supports multiple file formats once a R object is completed and ready for publication. The function in R markdown for this objective is called “knit”. The process includes running all computational components, then formats the outputs along with the narrative components. 

In R markdown, each computational component starts with three backwards apostrophes, with the language name and the code chunk options between the curly brackets shall be enclosed by three backwards apostrophes correspondingly. During the knitting process, computation components along with their results are laid out precedingly. Each narrative component, which is so called ordinary text with out code is combined within the computational components, resulting in a desired file. The final result is also customizable not only as in pdf or HTML format, but also includes editable formats such as Microsoft word documents. This conforms with the intention for a typical statistical report or presentation, that is, to make audience understand statistics with less to no statistical knowledge (Baumer, Cetinkaya-Rundel, Bray, Loi, and Horton, 2014).  R markdown fulfills this concept by offering modifiable documents for collaborators and other users to develop narrative components based on the statistical analysis results generated beforehand. 

While PDF and Word formats are commonly used by researchers in the fields for their formatting specification, they do not provide a pragmatical solution for interactive plots and graphics. Compared to static graphics, interactive graphics are extremely powerful for explanatory analysis, and complements the visualization prospect of statistical visualizations (Theus & Urbanek, 2008). Interactive graphics not only enhances the overall aesthetics of a visualization component, but could also reveal un-spotted insights. The findings may change conclusions and affect the narrative components, further changing the conclusion of a work (Healy,2018). Moreover, interactive visualization potentially provides a solution to readers with visual perception diseases such as color blindness (Wilke, 2019). HTML, another format producible by R markdown, is often underestimated in its ability for interactive visualization and animations. R has a variety of packages that supports interactive widgets which can by knitted and shown on HTML webpages. Despite the numerous packages and functions supported by R to create an interactive visualization, most of them requires an increase of workload in the computational components. A optimal solution of merging computational components that produce interactive graphics and the associated narrative components can be achieved by using the decorator function in listdown package (Kane,Jiang and Urbanek, 2020). The decorator pattern (Gamma, Helm, Johnson, Vlissides and Patterns, 1995) in the listdown function takes elements as arguments and returns the required object used for presentation in the specified output directory. When it comes to visualization components (ie. trelliscope), the plot is often fixed to a specific form pre-defined in the computation component. The goal is to make it live and interactive. This is possible by making use of the decorator function in listdown. 

## 1.2 Visualizations

The tools for presenting an interactive visualization was introduced previously. The remaining problem or perhaps one of the major limitations in order to create an effective interactive plot may be the big data sets most statistical tasks come across with nowadays (Ali, Gupta, Nayak and Lenka, 2016). The explosive growth of data becomes a trend and is still expanding fast accompanied by multiple factors such as the popularization 5G and IoT (Internet of Things). Statistical presentations and reports requiring visualizations on big data sets becomes more challenging and creative. Interactive graphics provides an ultimate solution, increasing the display power compared to a static plot (Weissgerber, Garovic, Savic, Winham and Milic, 2016). Among the various techniques on big data visualization problems, the principle of subsetting a large data set into multiple smaller ones and presenting them parallel are adapted by many solutions, including the famous ```ggplot2``` package (Wickham, 2011) that most Rmarkdown users are familiar with. Nevertheless, Package ```TrelliscopeJS``` (Hafen, Gosink, McDermott, Rodland, Kleese-Van Dam and Cleveland, 2013) further enhanced the idea by implanting interactive functions to ggplot items, the interface is especially effective for data with multiple categorical responses. In this paper, multiple graphical computational components are created using the above mentioned package, but we will start with simple examples such as the ```plotly``` package (Sievert, 2020), which turns static ggplot objects into interactive plots. The strength and weakness of each method, along with solutions on improving the functions effectively for their usage in the listdown package are then followed with examples. 

The remainder of this paper will go through as follows. The next chapter explains the motivaion of the listdown package and workflow on how the listdown generates documents from scratch. This is a background literature review summoning the previous work done by the package's developers (Kane,Jiang and Urbanek, 2020) using real world COVID data. This chapter also introduced the background of the data as it is used later on. Chapter 3 discussed the implementation of decorators using the same data from chapter 2, along with an executive summary on the graphical outputs. Chapter 4 focused on solving more complicated visualizations by writing functions to the decorator of the listdown package. Chapter 5 applied the mechanisms to the COVID data, and revealed the relationship of new cases and death number of each country by a specific time frame. The final chapter discussed the results of the output, concluded the limitations and further work. 


# CH2 Previous Work 

## 2.1 Motivation behind the Listdown Package

Lets suppose the data analyzing part and all coding work has completed for an analysis. The results of the analysis containing summary tables, data tables and plots which we referred to computational components earlier, are collected into lists of objects and saved as a RDS or RDATA format file. They are in the order of which the author would like to present them separately in respect to the whole analysis, the next thing is to produce the components from the lists into a document like a html file. This is a typical order of a data analyzing work processes, but it is not definite. The computational components are not required to be turned into lists, but it is often the case for R users when dealing with multiple computational components. The objects in RDS and RDATA format files can be restored and reproduced in R environment easily, and has many advantages.

Sometimes, the computational components along with the results they produce are stored in multiple locations, or in many cases, on different machines. It is particularly important to centralize them. They have multiple properties obtained naturally when turned into lists. Firstly, changing them into elements of a list generically provides a hierarchical structure for centralizing. Secondly, for most data, even on large scales, the actual presented contents are relatively small. Storing them into lists allows easier access and aligns with the concepts of centering. Last but not least, if the elements in the list are not in the order of a presentation desired, or changes accordingly, manipulating the order is much more convenient than non-centralized components. Nonetheless, the data cleaning and other processes iteratively repeats each time generating documents for presentation whenever knitr is used in a R markdown file. A R markdown file generally lacks semantic structure. When all computational components and narrative components are stored in one single file manually paragraphed by the author, extracting and editing components partially in a R markdown file often leads to increase of workloads after the changes are committed. 

During a statistical analysis, the analytical process and results can be seen as two parts which can be stored separately. If the results contain graphs and plots, they could be further stored in single named lists. As everything is organized in named lists, listdown has several advantages compared to normal R markdown files containing all computational and narrative components. First, it allows multiple pathways working in parallel from the same data. When the experiment and objective is different based on the same data set, computational components are expected to be different. This will affect the narrative components such as contexts and discussions, but the data set along with other processes such as cleaning and tidying remains constant. Since the different “pathways” can be stored into different lists, listdown package allows users to selectively pick the reproducible lists along with the narrative components. R markdown files shows the experiment in a serial way if different analyses from the same data are stored in the same file, or users will have to open two R markdown files with the same computational component for processing in both R markdown files. 

In addition, R markdown does not hold any data dedicated for the file itself. In order for a computational component in R markdown that reads in the data to work, the data set has to be stored or set to a pathway specifying the location of the data, depending on either it is saved locally or on a server. 
To overcome the above mentioned aspects, package listdown (Kane,Jiang and Urbanek, 2020) was introduced providing functions to programmatically create R markdown files from named lists. By using functions from the package, the components can be turned into a single named list, organized in a hierarchical structure. The contents of each list denoted, including the name and type of R object can be viewed in dendrograms. On top of the lists, decorators and other customizable functions can be added to assist the problem of visualizing. This is particular useful when large datasets are added to its corresponding computational component list and the author intends to present them. Large data sets requires a substantial amount of space to be fully shown.

Another advantage for using the listdown package is its capability to avoid repetitive work when data analysis updates. This is partially useful when data analysis process is updated frequently while the data source remains in the same format and standard. Once the computational components for data cleaning and process are constructed and stored into the list, the analysis may change the output such as results and plots. It may further change the narrative components. However, updating analysis methods does not mean deprecating the previous methods, listdown package allows different workflows and pathways to be stored and reproduced at anytime with a simple knitr, this vastly improves efficiency and drops tedious repetitive works while maintaining the objectives desired. 
Some useful areas of statistical analysis benefiting from the listdown package are mainly but not limited to it’s usage in clinical trial and medical data (Kane,Jiang and Urbanek, 2020).


## 2.2 Workflow
### 2.2.1 Working Steps
The workflow for users using the listdown package are described as the follows:
1. The computational components in R markdown are turned into list of objects, Each computational components are named, and is part of the named list. 
2. The named list containing all computational components are saved to the current directory on the disk as RDS or RDATA format files.
3. By using funciton listdown(), the RDS is then read into R as a listdown class object. At this step, multiple components are added. First, the required package for the current listdown object to run are specified. Second, the decorator argument are described. Third, initial expressions that runs before the listdown object is knitted are stated. Lastly, the document wide R chunk options are added here.
4. The header is then added, including the title of the output document, the author and the date. 
5. The lisdown object with the header are now sufficient to create a document, functions writeLines from package knitr (Xie, 2013) turns the listdown object to a R markdown file for rendering. 
6. The last step is to render the R markdown file to a output document. For the purpose of this paper, HTML format is ideal for all interactive plots and graphics. The R markdown is turned into markdown from knitr, the functions added in the listdown object at step 3 such as decorators and initial expressions injects through the kntting process, and produces the final HTML output. 
For the next part, the above steps will be explained in detail using a real world example data set. 

### 2.3 Case Study: COVID-19 Dataset Example

The data set regions from the __COVID-regions-2021.csv__ file( World Health Organization, 2021) is used in this first example. In this data set, 4 key information are contained. Firstly, all the WHO membership countries around the globe are grouped spatially and culturally according to the World Health Organization into regions. The six big WHO regions are: African Region, Region of the Americas, South-East Asia Region, European Region, Eastern Mediterranean Region, and Western Pacific Region. These regions are shown in each of their corresponding abbreviations under the variable _"WHO_region"_. Secondly, the date information for all of 2020 and the first quarter of 2021 is recorded under the _"Date_reported"_ variable, to be more exact, from 2020-01-03 to 2021-03-15. Thirdly, The number of new cases and the number of new deaths for each day of the regions has been included and named _"New_cases"_ and _"New_deaths"_. 4 visualizations produced using __ggplot2__ were saved in the markdown file named _computational_components_covid_ as lists. They are named "New cases per day for each region", "New cases per day for each region facet", "Cases against Death" and "Cases against Death facet", each containing their corresponding graphics. The first two plots used ```geom_area()``` to show the number of new cases recorded each day for all the regions in the given time frame. While the third and fourth plot shows the relationship of new cases against death recorded by day, and is plotted with ```geom_point()```. The main difference within the first and second plot, the third and the fourth plot, is the additional function call facet_wrap() in the ggplot function. In the facet_wrap arguments, a variable must be defined, such that the original data is seperately plotted in respect to the defined variable of the argument. This function allows each panel in the plot to show a subset or a proportion of the data, and has advantage in comparing patterns and trends. The function works well especially in the situation where there are severely overlapping data points, or when there are too much (but not over numbered) levels in the defined variable. Later in the journal, we will discuss advanced solutions to big data sets with multiple levels needing to be visualized effectively.  

Once data has been read into R, the computational component is created and stored along with the data into a named list, in this case, is called "computational_components_covid". It is then saved to the current directory as a R object. 

#### 2.3.1 Making a list of computational Components

```{r covid-example-step1}
library(listdown)
library(ggplot2)
library(tidyverse)
library(scales)
library(dplyr)
# Read in the regions data set.
regions = read.csv("COVID-regions-2021.csv", 
                    colClasses=c("character", "Date", rep("numeric", 2)))

# Creating the computational components
computational_components_covid <- list( 
  Data = regions,
  
  `New cases per day for each region` = ggplot(regions) + 
    geom_area(aes(Date_reported, New_cases, colour=WHO_region, fill=WHO_region), 
              stat="smooth", 
              alpha=.2, position="identity",
              method="loess", span=.1)+ labs(title = "Number of daily COVID cases by WHO region") +
    scale_y_continuous(expand = rep(0,4),labels = label_comma()) +
    scale_x_date(limits = as.Date(c("2020-01-01", "2021-03-15")),
                 expand = expansion(0),
                 label = label_date_short()),

`New cases per day for each region facet` = ggplot(regions, 
                                                   aes(x = Date_reported, y = New_cases, col = WHO_region, fill = WHO_region,
                                                                stat = "smooth",  method="loess", span=.1)) + geom_area( alpha=.5) + 
  facet_wrap(.~WHO_region) + labs(title = "Number of daily COVID cases by WHO region facet") + scale_y_continuous(expand = rep(0,4),labels = label_comma()) +
     scale_x_date(limits = as.Date(c("2020-01-01", "2021-03-15")),
                 expand = expansion(0),
                 label = label_date_short()),


`Cases against Death` = ggplot(data = regions,
       aes(x=New_cases, y=New_deaths, color = WHO_region)) + geom_point(alpha = .2) + 
    scale_x_sqrt() +
    scale_y_sqrt() +
  labs(title = "Number of COVID cases against death by WHO region"),
     

`Cases against Death facet` = ggplot(filter(regions, New_cases >= 0),
       aes(New_cases, New_deaths, colour=WHO_region)) + 
    geom_point(alpha=.2) +
    scale_x_sqrt() +
    scale_y_sqrt() +
    facet_wrap(vars(WHO_region)) +
    theme(aspect.ratio=1, legend.position="none") +
    labs(title = "Number of COVID cases against death by WHO region by facet")

)

#Save file to the disk
 saveRDS(computational_components_covid, "comp-comp_covid.rds")
 
comp_covid <- readRDS("comp-comp_covid.rds")

ld_cc_dendro(comp_covid)

```

After reading in our computational component that has been saved, the next step is to create a listdown object. The function __ld_cc_dendro()__ shows each object in the listdown in an descending order of depth (Kane,Jiang and Urbanek, 2020). Because every object in the component is named, it is also labeled in prior to the description of each object. 


#### 2.3.2  Creating a Listdown object

From the previous step, the list containing the plots now saved as a R object named _comp-comp_covid.rds_ goes through the following steps: A ```listdown``` object will be created. The object will be loaded into the designated document with a specified way, along with the libraries and codes required for the computational component. In this example, building the computational components in the list requires library ggplot2, tidyverse and scales, hence they are specified and loaded together with the saved computational object. Then the author decides how the elements in the list will be presented in the document. From the output, we can see ld_new is a listdown class object, the descriptions are as shown. Here, no decorators are added, the ggplot objects will be rendered just like any normal R markdown file. 

```{r covid-example-step2}
#Making a listdown object
library(listdown)
library(knitr)
ld_new <- listdown(load_cc_expr = readRDS("comp-comp_covid.rds"),
package = c("ggplot2", "tidyverse","scales"))

class(ld_new)
ld_new
```

#### 2.3.3 Header Options

The listdown object named __ld_new__ is now ready to create the document. To regularize the document output in terms of formats, it is further processed with a header. The listdown package has native support in R markdown and __workflowr__ as yml objects (Kane,Jiang and Urbanek, 2020). The header objects are part of the list in the document, and can be edited by using ```ld_rmarkdown_header()```. By calling the document name, a glimpse of the document content is shown, the names are clearly listed out along with the type of objects author intends to include. 

```{r covid-example-step3}
covidexample <- c(
 as.character(ld_rmarkdown_header("Covid plots",
author = "Leon",
 date = "2021")),
ld_make_chunks(ld_new))

covidexample
```

While the next major step is rendering the listdown object __covidexample__ into a _html_ document, there are still several steps included between. Firstly, by using generic R markdown function __writeLines()__, the listdown object is written into a R markdown file and is automatically saved into the pathway of the working directory of the current file. Next, it is rendered into a _HTML_ document using the __render()__ function generically from ```Rmarkdown```. Then the document can be knitted and shown using the __system()__ function or opened outside R. 

#### 2.3.4 Creating a HTML document from R markdown 

```{r covid-example-step4}
library(knitr)
library(rmarkdown)
# Write the document.
  writeLines(covidexample, "covid-example.Rmd")
  render("covid-example.Rmd",html_document())
 system("open covid-example.html")
```

##### 2.3.5 Number of New Cases

From the html document produced using listdown, the output of the computational components are shown directly to the reader. The first plot shows the number of new covid cases by regions. The tiny spike raised in the Western Pacific region's office indicated when the virus was first discovered in the People's Republic of China, and soon began it's transmission across the other regions. By March,the region of the Americas and the region of Europeans has increasing new cases inevitably. While European region seems to see a steady drop till July, the South-East Asia Region, Eastern Mediterranean Region and Africa region has shown noticeable number of new cases. Region of Americas at this time had new cases increasing rapidly towards the first peak. Region of Europeans soon showed an increase in the new cases after July, and the rate of increase is also increasing. Regions of America had the same trend with a higher rate of increase at the third quarter, along with region of Europeans, is contributing number of new cases much higher than other regions  towards the end of 2020. The situation up till today still does not seem to be optimistic, the final case study will reveal more information for the updated data set. The Second graph plotted regions separately along a common unaligned scale. The overlapping areas from the first plot can now be visualized clearer. Facetting by regions completely resolved the overshading problem, However, separation by regions for new cases is not as effective as showing the number of new cases against death in the third and fourth graph. 

##### 2.3.6 Number of New Cases and Death

The third and fourth graph reveals the relationship of number of new cases and number of death in the specified time frame. The advantage of facetting becomes obvious in this situation. Scattered points spreaded around the bottom left corner of the graph area, such high dense of observation makes interpretation almost impossible. The final plot subsets the original scatterplot into different regions, and used different color cues to highlight each region uniquely. Almost all regions shows a high number of death as the number new cases increases, and follows a positive linear relationship except for European region. With the increasing number of new cases, the number of death seperates into two extremes. On one side of the Y-shaped branch, the number of death accompanied by number of new cases are significantly lower than other regions and vice versa on the other branch. According to WHO website and Wikipedia's page COVID-19 pandemic in Europe, the lack of Vigilance and failure of taking effective action in most European countries leads to the high death number over the who region. 


# CH3 The Usage of Decorators 

## 3.1 Case Study: COVID-19 Dataset Example with decorators 

In the previous chapter, the complete workflow of creating a document using listdown package is demonstrated with a real world data. The example is relatively simple and straight forward. After a glimpse of the document once it is rendered and produced, two main points of interest arises. After all, the plots are informative, but they are also static. This limits the overall demonstrative ability of both plots. As the data set contains information for each individual day in the time frame consistently, but only the overall trends and robust numbers are shown in the first set of plots. More detailed information are lost in a trade-off to revealing the robust trend of new cases daily by regions. In the second set of plots, the scattered points also fails to give any addition information of the exact observation, even though it had the data information of doing so. The identification feature of a visualization can be greatly improved using interactive graphics (Cook, Swayne & Buja, 2007), the listdown package adapts this idea and allows author implanting addition decorators to the original listdown object during the processing of producing the document. The decorator control of listdown could be customized for an interactive plot, for example, Package plotly (Sievert, 2020). The package provides a native support turning ggplot objects into interactive HTML widgets. 

```{r covid-decorator-example-step1}
#Add in data and decorators
library(listdown)

ld_decorator <- listdown(load_cc_expr = readRDS("comp-comp_covid.rds"),
package = c("ggplot2", "tidyverse","scales", "plotly"),
decorator = list(ggplot = ggplotly))

class(ld_decorator)
ld_decorator
```

In this example, the RDS file __comp-comp_covid.rds__ remains the same as the previous example. From the description of the ld object, the computational components are identical, the only difference tends to be the decorators and it's associated packages imported.

<!-- NOT SURE -->

Referring to step 3 in chapter 2.2.1, the decorator is a description of the function from the computational components in the list being created. The decorator Itself is not a function call evaluatable by R, it describes the method of the function to be rendered during the process of knitting. From the mechanism described in Kane,Jiang and Urbanek (2020), the computational components goes though the decorator methods sequentially searching from the name using the generic R function inherits(). When the function from the computational component finds the matching name of the decorator by the first element it can inherit from, the method described by the decorator argument is applied. When Knitr(Xie, 2013) renders the R markdown file into a HTML document, the description stated in the decorator are injected to the markdown file telling the knitr to use the decribed method in the decorator instead of the original function arguments. In this case, the first step is to attach the packages required for listdown to render the document from the listdown object. In addition to the case study in chapter 2.3, because we are using ```ggplotly``` from the plotly package as a decorating method, package plotly is also attached along with the other packages. The next step is to replace the ggplot function call with the decorator ggplotly. This means when the listdown objects are rendered, the method ggplotly will be used instead of ggplot and will be applied on all ggplot class objects within the list. From here, a simple header will be added and the HTML document will be produced. 

<!-- NOT SURE -->



```{r}
coviddecoratorexample <- c(
  as.character(ld_rmarkdown_header("covid-example")),
          ld_make_chunks(ld_decorator))


writeLines(coviddecoratorexample, "covid-decorator-example.Rmd")
render("covid-decorator-example.Rmd",html_document())
system("open covid-decorator-example.html")
```

##### 3.1.1 Number of New Cases with decorators

After using ggplotly as a decorator method, the exact numbers of new cases can new be assessed directly in the plotting area. To be general, only the highest number of new cases from each region with the date observed will be report. The rest of the information are left with interest for the readers to interpret and explore. The first set of plots shows the highest number of new cases in a single day in the given time frame was 769,644 cases observed from the region of Americas, and it was the 19th of September 2020. The highest new cases observed in a single day in the regions of Africa was the 3rd of January, 2021, with the exact number of 40456. The highest new cases observed in a single day in the regions of Eastern Mediterranean was the 1st of December, 2020, with the exact number of 62206. The highest new cases observed in a single day in the regions of European was the 8th of November, 2020, with the exact number of 346573. The highest new cases observed in a single day in the regions of South East Asia was the 23th of December, 2020, with the exact number of 78377. Finally, the "lowest" region with highest observed number of new cases in a single day was Western Pacific region, at the number of 15155, on the 13th of February, 2020. 


##### 3.1.2 Number of New Cases and Death with decorators

The highest number of death and the date observed were also revealed. To be general, the information will be reported like chapter 3.1.1, rest of the information are also with interest for the readers to interpret and explore. 

## 3.2 Docorators for more complicated computational compontents

<!-- NOT SURE -->

The previous example reflected the improvements in visual perception by using decorators compared to static plots. However, both cases were considered as basic usage in the prospect of decorator introduction from On the Programmatic Generation of Reproducible Documents (Kane,Jiang and Urbanek, 2020). The ggplot
takes two main arguments when producing a plot. First, the source of the data desired to be visualized are stated. Then the aes() argument maps components of the data set to the components in a visualization. The computational components from chapter 2.3 contains the plotting mechanism and the actual plots stored as list type objects. The decorator method, function ggplotly seeks all the mapping components in the same directory as a ggplot during the mapping process. However, that is not always the case. The methods described by decorators can sometimes seek mapping components in different directories, or pathways. If this happens, the described decorator method inherits the original function in the computational component, but fails to find the mapping components required, the decorator method will fail to work and return an error message indicating the problem. In the next example, we have used another set of data from the _gapminder_ package (Bryan, 2017). There are two main aspects demonstrated by the following example. Firstly, as previous examples demonstrated, despite facetting is an effective visualization method, but when the data set has variables with a large number of categorical levels, the original function facet_wrap() embedded in package ggplot2 may become inefficient. The package trelliscope (Hafen, Gosink, McDermott, Rodland, Kleese-Van Dam and Cleveland, 2013) subsets data into groups and facets the plots arranging each plot in a grid. Although it provides a better solution compared to facet_wrap, the second aspect arises when it is used in a computational component of a listdown object. The method described by the decorator seeks a different pathway in the mapping process that is not originally defined by the function in the computational component from the list. 

<!-- NOT SURE -->

### 3.2.1 Visualizing the Gapminder Data Set

The original data was loaded and added into the list of files. From the description (Bryan, 2017), the gapminder data set contains information on the life expectancy, GDP per captia and population of 142 countries with their continents from 1952 to 2007. In comparison to the case study from chapter 2.3, the designated facetting variable increased from 6 to 142. We will repeat the listdown workflow process, the RDS file saved are used in the next chapter for advanced solutions. The chunk of codes below produces a ggplot with __facet_wrap()__ using listdown. the final layout is folded because of too much plots inserted onto the same panel. The trelliscopejs package(Hafen, Gosink, McDermott, Rodland, Kleese-Van Dam and Cleveland, 2013) converts ggplot with __facet_wrap()__ argument into individual plots with interactive interface. This package provides us a potential tool expanding each seperate plot on multiple panels, which will be discussed later in the paper. 
. 
```{r}

library(ggplot2)
library(gapminder)
library(listdown)
library(gapminder)
library(trelliscopejs)
library(ggplot2)
library(tidyverse)
library(DT)
library(rmarkdown)

# Load the gapminder data set.
data(gapminder)
# gapminder$country[gapminder$country == "Cote d'Ivoire"] = "CotedIvoire"

 
# Creating the computational components
comp_comp_gapminder <- list(
  Data = gapminder,
  `life expectancy` = ggplot( gapminder) + geom_point(aes(x = year, y = lifeExp)) + 
  xlim(1948, 2011) + ylim(10, 95) + 
  theme_bw() + 
  labs(title = "life expectancy by continent") +
  facet_wrap(~ country + continent))

#Save file to the disk
 saveRDS(comp_comp_gapminder, "comp-comp_gapminder.rds")

 
# A not very effective visualization
ld_gapminder <- listdown(load_cc_expr = readRDS("comp-comp_gapminder.rds"),
package = c("ggplot2","gapminder"))

gapminder_example <- c(
 as.character(ld_rmarkdown_header("gapminder plots",
author = "Leon",
 date = "2021")),
ld_make_chunks(ld_gapminder))

 writeLines(gapminder_example, "gapminder-example.Rmd")
  render("gapminder-example.Rmd",html_document())
  system("open gapminder-example.html")
```

### 3.2.2 TrelliscopeJS

In the previous writings, trelliscopejs package was mentionaed several times as a substitution to facetting functions in ggplot. The idea behind trelliscope described as D&R, standing for divide and recombine (Guha, Hafen, Rounds, Xia, Li, Xi, & Cleveland, 2012), was an approach in analytical method to solve large complex data visualizations. In a trelliscope system, the data set are splited into subets, with a visualization method applied to each subsets. The output is a structurally arrayed panel displaying the visualizations(Hafen, Gosink, McDermott, Rodland, Kleese-Van Dam and Cleveland, 2013). To implant this approach into ggplot2 interface, __facet_trelliscope()__ was introduced. The next example shows a simple change in the function solving the problem in chapter 3.2.1. 

## 3.2.3 Facetting using Package TrelliscopeJS 

After using __facet_trelliscope()__, the gapminder data set returns an visual output much more interpretable than before. However, this was created in a normal R markdown workflow. 

```{r}  
# What trelliscope would look like when we use trelliscope instead of facet
library(ggplot2)
library(trelliscopejs)
library(gapminder)
ggplot(gapminder) + geom_point(aes(x = year, y = lifeExp)) +
  xlim(1948, 2011) + ylim(10, 95) + theme_bw() +
  facet_trelliscope(~ country + continent, nrow = 2, ncol = 7, width = 300)

```

### 3.3 facet_trelliscope() workflow

Despite the example in next section (chapter 3.3) works flawlessly with a simple swap of function from __facet_wrap()__ to __facet_trelliscope()__, the mechaism behind is as describes Firstly, most objects in R has a class attribution that defines the class of the object it belongs to. The __inherits()__ function in __facet_trelliscope()__ searches for the attributions to find the data. If the __inherits()__ function successfully finds the data from the attributes list, it uses the data found from first layers of the attributes list, and that is the case of using __facet_trelliscope()__ in listdown. In another case, data may not be available and user will have to supply it in the argument. In this situation, the attribute of data is specified as "WAIVER" object, indicating the calling function should just use the default value. Sometimes, if the data's attribute is "NULL", meaning the data itself does not exist, the function will return an error message stating the corresponding errors. There is a problem from this workflow in regards to the first situation when __facet_trelliscope()__ is used in listdown. The default for __inherits()__ searching data is NULL, the pathway tells the function call there is no available data, but infact, the data is present in the listdown object. In the next chapter, several approaches to solve this issue are discussed.  

# CH4 Solution using Decorators

As previous examples demonstrated. The decorator indicates a name of method or function that are applied to the stated class of object in the listdown file during kniting process. The goal is to swap __facet_wrap()__ with __facet_trelliscope()__, and it requires partially changing the function call of the ggplot object in listdown. One fast solution was to exclude the __facet_wrap()__ function from the listdown file and add __facet_trelliscope()__ through __initial_expr()__ argument. The code chunk in __initial_expr()__ is inserted immediately once the required libraries are loaded. When render is kntting the listdown object, codes in __initial_expr()__ is evaluated before the listdown objects are rendered. The following example demonstrates this approach.

## 4.1 Adding telliscopejs facet for Gapminder in listdown

To exclude the facet argument, we recreated the computational component with no facet arguments, and save the list into an RDS file named _comp-comp_gapminder_trellis.rds_. Everything else remains the same  within a normal R markdown workflow. 

```{r}
# Creating the computational components, this time without the 'facet_wrap' call.

comp_comp_gapminder_trellis <- list(
  Data = gapminder,
  `life expectancy full` = ggplot(gapminder) + geom_point(aes(x = year, y = lifeExp)) + 
  xlim(1948, 2011) + ylim(10, 95) + 
  theme_bw() + 
  labs(title = "life expectancy by continent"))

#Save file to the disk
 saveRDS(comp_comp_gapminder_trellis, "comp-comp_gapminder_trellis.rds")
```

The new function __ggtre()__ is created in the intial expression. The function consists of two parts, the first being the original function call. In this example, it was the ggplot objects in the listfown file. The dseonf part is the __facet_trelliscope()__ arguments with the facetting variables and other parameters. The crucial key here is the pathway of the function call. Trelliscope attempts to find the variable attributes with default, which is NULLdata. By adding a pathway using __path="."__ argument, facet_trelliscope now changes the pathway to the current working directory. once knitr is called from rendering the listdown object, initial expression gets evaluated first. The decorator method is directed to the right pathway containing the elements need for the trelliscope argument. 

```{r}
library(listdown)
# Adding trelliscope call in the initial expressions, notice the description: Path ="."

ld_gapminder_trellis <- listdown(load_cc_expr = readRDS("comp-comp_gapminder_trellis.rds"),
package = c("ggplot2","gapminder", "trelliscopejs"),
decorator = list(ggplot = ggtre), 
init_expr = {
  ggtre = function(x) x + facet_trelliscope(~ country + continent,
                                           nrow = 2, ncol = 7, width = 300, path = ".")
}
)
ld_gapminder_trellis
```

From the description of the listdown method above, the initial expression that gets to run immediately after packages are loaded are now included. The decorator method for ggplot class objects are now rendered using the method __ggtre()__ described in the initial expression. The next chunk of codes follows a normal listdown workflow and produces the docuemnt _gapminder_trellis-example.html_, implementing trelliscope to ggplot. 


```{r}
library(rmarkdown)
gapminder_trellis_example <- c(
 as.character(ld_rmarkdown_header("gapminder plots using trelliscope",
author = "Leon",
 date = "2021")),
ld_make_chunks(ld_gapminder_trellis))

 writeLines(gapminder_trellis_example, "gapminder_trellis-example.Rmd")
  render("gapminder_trellis-example.Rmd",html_document())
  system("open gapminder_trellis-example.html")

```

### UNABLE TO SOLVE 

Error: lexical error: invalid bytes in UTF8 string.
          Cook Islands","Costa Rica","C������te d������Ivoire","Croati
                     (right here) ------^



Each country can now be shown clearly like the output from a normal R markdown workflow. However, in this approach, the function in the listdown file was modified specially to fit the requirement for using __ggtre()__ added. It was also suggested that the number of initial expression and the complexity of the initial expression shall be kept minimal (Kane,Jiang and Urbanek, 2020). The initial expression is considereably long in this case, and could be even longer if further arguments were added. Furthermore, the variables from function __ggtre()__ only works for this specific data. If the user wishes to visualize another data set, not only the function of the ggplot within the listdown file needs to be modified, but also the variables in __ggtre()__ needs to be the same as the original ggplot's facet argument. A more generalized approach shall be developed. 

## 4.2 A More Generalized Solution

### 4.3 facet_wrap to facet_trelliscope
The common ground for  __facet_wrap()__ and __facet_trelliscope()__ is their concept of dividing the data into smaller subsets and recombine them into either a panel or multiple arrays of plots. For the two different arguments, the variable used as the subsetting condition is the same through out the process. If a function could pull the facetting variables out from __facet_wrap()__, then places it into __facet_trelliscope()__, then we could get rid of the __facet_wrap()__ in the function without the need to modify the original ggplot funtion from listdown. The only problem remains is the facetting layer left in the old ggplot arguments which needs to be removed and replaced by the new trelliscope facets. The function __facet_wrap2ts()__ was designed to solve the issues mention above. This solves the problem from chapter 4.1 in a more generalized way, no modifications needs to be carried out on the original ggplot function in listdown. 

#### 4.3.1 Function facet_wrap2ts

```{r}  
# Created a generic function for trelliscope
# y is an ggplot object
facet_wrap2ts <- function(y){
  if (is(y$facet, "Facet") && !is(y, "FacetNull")) {
  ## get variables
  v = y$facet$vars()
  ## construct Null facet to replace it
  o = ggplot()
  facetNull = o$facet
  y$facet = facetNull
  ## construct the formula
  form = eval(parse(text=paste0("~ ", paste(v, collapse=" + "))))
  ## construct call
  c = as.call(list(quote(facet_trelliscope), form,
                   ncol = 2, path="."))
  y + eval(c)
  } else y
}

```

This function works as follows: 

1. we assume y is a ggplot class object in the listdown object, and it has an argument for facet. The first __if__ statement states that facet argument of the ggplot objecy y must have a facet and must not be the class "facetNULL", or empty, which means there simply is no facet. Then the transfomation process is continued. 

2. Next, a vector v is created, which obtains the variable names from the facet argument within the ggplot object y. The variable names in v are important because it will be passed to __facet_trelliscope()__'s facet arguments. We are not changing any variables of the data to visualize at this step, but the function of which the variables gets fed into. 

3. Now, because the ggplot object y still has the original layer of facet that needs to be replaced by the new trelliscope facet, we created an empty ggplot object __o__. Then the empty facet attribution named _facetNULL_ in object __o__ gets pulled out. _facetNULL_ are then injected into the already existing facet attributes in y. Up to this step, y still remains to be the exact same ggplot object as original, except without the facet argument. 

4. The formula is then created using the original facet variables previously stored in v and the correct syntax. It is converted from an R object of the character class to an R object of the expression class. Before step 5, it is evaluated and ready to be used to build the function call. 

5. The next step is constructing the function call. __facet_trelliscope()__ argument were implanted with the new formula named _form_ from the previous steps. 

6. The last step is to call the original ggplot object y combined with the evaluated result of the new function __c__. This returns an output that shall look identical to using __facet_trelliscope()__ in normal R markdown files.

7. There are also cases this decorator is applied improperly, for example when the ggplot object y does not contain any facet arguments, that is the attribute being facetNULL. This is encountered by using the __else__ from the if loop. The output remains the exact same of y untouched. If users intend to add a __facet_wrap()__ as a decorator, then function style __ggtre__ can be used. It requires the user to manually set the variables for facetting, and the decorator function shall be included as an intial expression, which gets evaluated before the knitting process. 

#### 4.3.2 Testing facet_wrap2ts on Gapminder Data set

To testify if the function works for the gapminder data set, the same listdown object was used from chapter 3.2.1. This time, the initial expression was removed, and the decorator was changed to the new function. the listdown object was saved as _ld_gapminder_trellis_generic_. After adding the headers, we rendered the document to check the outputs. 

```{r}
## Same data set as the first example, switching the decorator this time instead of adding initial expression
ld_gapminder_trellis_generic <- listdown(load_cc_expr = readRDS("comp-comp_gapminder.rds"),
package = c("ggplot2","gapminder", "trelliscopejs"),
decorator = list(ggplot = facet_wrap2ts)
)

gapminder_trellis_generic_example <- c(
 as.character(ld_rmarkdown_header("gapminder plots trelliscope generic",
author = "Leon",
 date = "2021")),
ld_make_chunks(ld_gapminder_trellis_generic))

 writeLines(gapminder_trellis_generic_example, "gapminder_trellis_generic-example.Rmd")
  render("gapminder_trellis_generic-example.Rmd",html_document())
  system("open gapminder_trellis_generic-example.html")
```

After applying the __facet_wrap2ts__ decorator function, the rendering showed a promising result of the HTML document. 


### 4.4 facet_wrap directly to facet_trelliscope with plotly

The  __facet_wrap2ts__ was successful in turning ggplot objects with facet argument into trelliscope plots in listdown. However, during big data set visualizations, we saw the power of ggplotly as a decorator from example 3.1. 


#### 4.4.1 Function facet_tsplotly

```{r}
facet_tsplotly <- function(p) {
  if (is(p$facet, "Facet") && !is(p, "FacetNull")) {
    v = p$facet$vars()
    o = ggplot()
    FacetNull = o$facet
    p$facet = FacetNull
    form = eval(parse(text=paste0("~ ", paste(v, collapse=" + "))))
    c = as.call(list(quote(facet_trelliscope), eval(parse(text=paste0("~ ", paste(v, collapse=" + ")))),
                     ncol = 2,path=".", as_plotly = TRUE))
    p + eval(c)
  }  else p
}
```


#### 4.4.2 Testing facet_tsplotly on Gapminder Data set

```{r}
library(plotly)
## Still the same data set as the first example
ld_gapminder_trellis_plotly <- listdown(load_cc_expr = readRDS("comp-comp_gapminder.rds"),
package = c("ggplot2","gapminder", "trelliscopejs","plotly"),
decorator = list(ggplot = facet_tsplotly)
)

gapminder_trellis_plotly_example <- c(
 as.character(ld_rmarkdown_header("gapminder plots trelliscope plotly",
author = "Leon",
 date = "2021")),
ld_make_chunks(ld_gapminder_trellis_plotly))

 writeLines(gapminder_trellis_plotly_example, "gapminder_trellis_plotly-example.Rmd")
  render("gapminder_trellis_plotly-example.Rmd",html_document())
  system("open gapminder_trellis_plotly-example.html")
```




# CH5 Case Study: Reporting number of new cases and Death information from COVID Data
From the previous examples, the trelliscopeJS works especially well with big data set having variables with multiple levels. The plotly interactive plots show more details on individual plots. 


## 5.1 Applying the decorator
```{r}
library(trelliscopejs)
library(listdown)
library(tidyverse)
library(rmarkdown)
#Reading in the data
covidcountries <- read.csv("WHO-COVID-19-global-data.csv",
                     colClasses=c("Date", rep("character", 3), 
                                   rep("numeric", 4)))

# Creating the list
comp_comp_covid_trellis <- list(
  Data = covidcountries,
  `New cases per day for each Country` = ggplot(covidcountries) + geom_point(aes(x=Date_reported, y=New_cases, group=Country), size = 0.6) + 
  geom_line(aes(x=Date_reported, y=New_cases, group=Country), size = 0.4) +  scale_x_date(date_breaks = "3 month", date_labels =  "%b %Y") +
    theme_bw() +
  labs(title = "New cases per day by Country") + 
    facet_wrap(vars(Country))
    )

#Save file to the disk
 saveRDS(comp_comp_covid_trellis, "comp-comp_covid_trellis.rds")
 
 
# Creating the listdown package
ld_covid_trellis <- listdown(load_cc_expr = readRDS("comp-comp_covid_trellis.rds"),
package = c("ggplot2","trelliscopejs"),
decorator = list(ggplot = facet_tsplotly)
)

# Adding a header
covid_trellis_example <- c(
 as.character(ld_rmarkdown_header("Covid plots using trelliscopeJS",
author = "Leon",
 date = "2021")),
ld_make_chunks(ld_covid_trellis))

# Rendering
 writeLines(covid_trellis_example, "covid_trellis-example.Rmd")
  render("covid_trellis-example.Rmd",html_document())
  system("open covid_trellis-example.html")
  
```




## 5.2 Discussion



# CH6 Conclusion and Further Work

## 6.1 Conclusion
The objective from this article, to 

## 6.2 Further Work






























