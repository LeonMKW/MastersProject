---
title: "mastertrial"
author: "Mingkun Wu"
date: "11/26/2020"
output: html_document
---



```{r}
Sys.setenv(LANG = "en")
library(listdown)
library(ggplot2)
library(gtsummary)
library(flextable)
library(dplyr)
library(survival)
library(survminer)
library(rmarkdown)
library(plotly)
library(gapminder)
library(trelliscopejs)
library(DT)
library(knitr)
```



# Abstract {-}

Statisticians and analysts have been using R for a long time. R programming environment has reproducible document standards embedded, such as R markdown. While R markdown requires the programmer to manually construct the structure of reproducible file, R list-down Package provides a programmatic solution to generate the files. On top of the already available R list down package, this paper demonstrates implanting graphs and interactive plots when users generate any reproducible documents by using ```trelliscopejs package```. The concept is followed by a demonstration using gapminder dataset. 
\newpage




```{css, echo = FALSE}
<center> <h1>1 Introduction</h1> </center>
```


The R markdown (Baumer, Cetinkaya-Rundel, Bray, Loi, and Horton, 2014) demonstrates the possibility of constructing reproducible documents using R language. The format allows author to integrate R codes, written work, data tables, visualization plots and much more information into one directly structured document. Amongst scientific writings and analytical reports knitted using R markdown, the majority are made up of codes and narrative writings. The codes are usually but not limited to common computing languages, such as R, Python, SQL and others. The writings which contextualize the codes usually follow the codes. Sometimes writings are also placed between the codes using a hash. In this paper, the chunk of computing codes and the narrative writings will be referred to computational components and narrative components respectively (Kane,Jiang and Urbanek, 2020). 

R markdown 
Statistical analysis tends to be more reachable and interpretable to public audience accompanied by the rapid rise of computing abilities. While the statistical computing threshold lowers with the invention of R language, the needs to integrate computationally derived objects with narrative explanations arise. The usage of R markdown centralizes different data types with a specific format, further process with the technical work in a computationally organized way. Usually in most data analysing tasks, the first thing is data cleaning and tidying. However, this processes usually requires other environments and configuration to manipulate. Such steps have different needs in computational purpose than report or presentations. It may not become fully shown using R code or other languages natively supported by R, but authors often use narrative texts to describe the associate processes. These narrative texts can be fully embedded in the R markdown file for readers to follow without opening other documents. 

Before a highly informative presentation, multiple explanatory analyses are often carried out. These explanatory analyses contain numerous amounts of table, plots and graphs, most of them have comments and notes. R markdown can save the robust components and generate documents without spending time on layouts and formats. 

The advantage of R markdown’s narrative feature can be demonstrated in multiple prospects. Firstly, R markdown is as its names implies, a Markdown mark-up language of R. By using combinations of codes and embedding symbols to control the formatting and layout of a R object file, users gets the desired final output document. All of these are easy to achieve without extensive skills in coding and consumes less time and effort to learn. Packages such as “bookdown” (Xie, 2016) demonstrates the easiness for users indenting to edit long narrative components in contrast of using another commonly-used markup language – Latex. While latex may be more expressive in terms of proficiency in terms of academical writing, the coding alike syntax required to produce documents takes a substantial amount of time and effort to learn and is relatively more complicated than R markdown’s syntax. 

On the other hand, statistical reports and presentations often contains numerous computational and narrative components. R markdown supports multiple file formats once a R object is completed and read for publishing. The function in R markdown for this objective is called “knit”. The process includes running all computational components, then formats the outputs along with the narrative components. 
Each computational component starts with ```{}, with the language name between the curly brackets and ends with ```. During the knitting process, computation components along with their results are laid out precedingly. Each narrative component, which is so called ordinary text with out code is combined within the computational components, resulting in a desired file.  
The final result is also customizable not only as in pdf or HTML format, but also includes editable formats such as Microsoft word documents. This conforms with the intention for a typical statistical report or presentation, that is, to make audience understand statistics with less to no statistical knowledge (Baumer, Cetinkaya-Rundel, Bray, Loi, and Horton, 2014).  R markdown fulfils this concept by offering modifiable documents for collaborators and other users to develop narrative components based on the statistical analysis results generated beforehand. 
While PDF and Word formats are commonly used by researchers in the fields for their formatting specification, they do not provide a pragmatical solution for interactive plots and graphics. Compared to static graphics, interactive graphics are extremely powerful for explanatory analysis, and complements the visualization prospect of statistical visualizations (Theus & Urbanek, 2008). HTML, another format producible by R markdown, is often underestimated in its ability for interactive visualizations. R has numerous packages that supports interactive widgets which can by knitted and shown on HTML webpages. This paper will demonstrate how the interactive graphics can be implemented into HTML using package Listdown. 

```{css, echo = FALSE}
<center> <h1>2 Background</h1> </center>
```


Lets suppose the data analyzing part and all coding work has completed. The results of the analysis containing summary tables, data tables and plots which we referred to computational components, are collected into a list of objects. They are roughly in the order of which we would like to present them, the next thing is to present the components in a document like html. This is a typical order of a data analyzing work processes, but it is not definite. 

Sometimes, the computational components along with the results they produce are stored in multiple locations, or in many cases, on different machines. It is particularly important to centralize them. There are many advantages turning them in lists. Firstly, turning them into list of elements naturally provides a hierarchical structure for centralizing. Secondly, for most data, even on large scales, the actual presented contents are relatively small. Storing them into lists allows easier access and aligns with the concepts of centering. Last but not least, if the elements in the list are not in the order of a presentation desired, or changes accordingly, manipulating the order is much more convenient than non-centralized components.  

R Listdown
Nonetheless, the data cleaning and other processes iteratively repeats each time generating documents for presentation whenever knitr is used in a R markdown file. A R markdown file usually lacks semantic structure. When all computational components and narrative components are stored in one single file manually paragraphed by the author, extracting and editing components partially in a R markdown file often leads to increase of workloads after the changes are committed. 
In addition, R markdown does not hold any data dedicated for the file itself. In order for a computational component in R markdown that reads in the data to work, the data set has to be stored or set to a pathway specifying the location of the data, depending on either it is saved locally or on a server. 
To overcome the above mentioned aspects, package listdown (Kane,Jiang and Urbanek, 2020) was introduced providing functions to programmatically create R markdown files from named lists. By using functions from the package, the components can be turned into a single named list, organized in a hierarchical structure. The contents of each list denoted, including the name and type of R object can be viewed in dendrograms. On top of the lists, decorators and other customizable functions can be added to assist the problem of visualizing. This is particular useful when large datasets are added to its corresponding computational component list and the author intends to present them. Large data sets requires a substantial amount of space to be fully shown.
 



During a statistical analysis, the analytical process and results can be seen as two parts which can be stored separately. If the results contain graphs and plots, they could be further stored in single named lists. As everything is organized in named lists, the package has several advantages compared to normal R markdown files containing all computational and narrative components. The first is it allows multiple pathways working in parallel from the same data. When the experiment and objective is different based on the same data, computational components are expected to be different. This will affect the narrative components such as conclusions and discussions, but the data and other process remains constant. Since the different “pathways” can be stored into different lists, listdown package allows users to selectively pick the reproducible lists along with the narrative components. Normal R markdown files shows the experiment in a serial way if different experiments are stored in the same file, or users will have to open two R markdown files with the same computational component for processing in both R markdown files. 

Another advantage for storing objects in a list is its capability to avoid repetitive work when data analysis updates. This is partially useful when data analysis process is updated frequently while the data source remains in the same format and standard. Once the computational components for data cleaning and process are constructed and stored into the list, the analysis may change the outputs, such as results and plots. Further changing the narrative components. However, updating analysis methods does not mean deprecating the previous methods, listdown package allows different methods to be stored and reproducible at anytime with a single knitr, this vastly improves efficiency and drops tedious repetitive works while maintaining the objectives desired. 
Some useful areas of statistical analysis benefiting from the listdown package are mainly but not limited to it’s usage in clinical trial data (Kane,Jiang and Urbanek, 2020). 

The __Rlistdown__ package highly integrates a bundle of computational components into a list of objects. However, when it comes to visualization components (ie. trelliscope), the plot is fixed to a specific given data. Our goal is to make it live and interactive. That is, when the author inputs different data, the plot changes correspondingly. 




```{css, echo = FALSE}
<center> <h1>2 Background</h1> </center>
```


Lets suppose the data analyzing part and all coding work has completed. The results of the analysis containing summary tables, data tables and plots which we referred to computational components, are collected into a list of objects. They are roughly in the order of which we would like to present them, the next thing is to present the components in a document like html. This is a typical order of a data analyzing work processes, but it is not definite. 

Sometimes, the computational components along with the results they produce are stored in multiple locations, or in many cases, on different machines. It is particularly important to centralize them. There are many advantages turning them in lists. Firstly, turning them into list of elements naturally provides a hierarchical structure for centralizing. Secondly, for most data, even on large scales, the actual presented contents are relatively small. Storing them into lists allows easier access and aligns with the concepts of centering. Last but not least, if the elements in the list are not in the order of a presentation desired, or changes accordingly, manipulating the order is much more convenient than non-centralized components.  


The data Anscombe Quartet from the __datasets__ package( R Core Team 2012) is used in this first example. Four scatter plot produced using __ggplot2__ was saved in the markdown file named _computational components_ as lists. They are named "Linear", "Non Linear", "Outlier Vertical" and " Outlier Horizontal", each contains their corresponding graphics. We can see the class of the R object _comp_ is a list.

```{r}
library(ggplot2)

 # Load the Anscombe Quartet.
 data(anscombe)
 
# Create the ggplot objects to display.
 computational_components <- list(
 Linear = ggplot(anscombe, aes(x = x1, y = y1)) + geom_point(),
 `Non Linear` = ggplot(anscombe, aes(x = x2, y = y2)) + geom_point(),
 `Outlier Vertical`= ggplot(anscombe, aes(x = x3, y = y3)) +
 geom_point(),
 `Outlier Horizontal` = ggplot(anscombe, aes(x = x4, y = y4)) +
 geom_point())

 # Save the file to disk to be read by the output R Markdown document.
 saveRDS(computational_components, "comp-comp.rds")
 
comp <- readRDS("comp-comp.rds")
class(comp)

```


## 2.1 Creating the document using Package Listdown

The list containing the plots is now saved as a R object named _comp-comp.rds_. From here, the document goes through the following steps: A ```listdown``` object will be created. The object will be loaded into the designated document with a specified way, along with the libraries and codes required for the computational component. Then deciding how the elements in the list will be presented in the document. 

Now we load in the listdown package to make a document. We define how the list of objects will be loaded into R. The header for the markdown file is also embedded, shown in the example named _doc_. 

```{r}
library(listdown)

ld <- listdown(load_cc_expr = readRDS("comp-comp.rds"),
package = "ggplot2")
```

The R object named __ld__ is now ready to create the document. To make the document more sufficient, the document is further processed with header. The listdown package has native support in R markdown and __workflowr__ as yml objects. All objects are part of the list in the document, and can be edited by using codes.


```{r}
anscombeexample <- c(
 as.character(ld_rmarkdown_header("Anscombe's Quartet",
author = "Francis Anscombe",
 date = "1973")),
ld_make_chunks(ld))

anscombeexample
```

By calling the document name, we can see a glimpse of the document, the contents are clearly listed out along with the type of the object. To make the document fully reproducible, the library required for the computational components are also listed. The below codes renders __anscombeexample__ into a _html_ document. 

```{r}
# Write the document.
writeLines(anscombeexample, "anscome-example.rmd")
render("anscome-example.rmd",html_document())
#system("open anscome-example.html")
```

## Covid regions example

Now the data is not originally from a package, but a data set we choose. 

```{r}
library(tidyverse)
library(scales)
#creating ld items
regionsdf = read.csv("COVID-regions-2021.csv", 
                    colClasses=c("character", "Date", rep("numeric", 2)))


computational_components_covid <- list( 
  Data = regionsdf,
p1 = ggplot(regions, aes(x = Date_reported, y = New_cases, col = WHO_region, fill = WHO_region)) + 
  geom_area() + facet_wrap(.~WHO_region) + labs(title = "Number of daily COVID cases by WHO region") + scale_y_continuous(expand = rep(0,2),labels = label_comma()),

p2 = ggplot(data = regions,
       aes(x=New_cases, y=New_deaths, color = WHO_region)) + geom_point()
)
         
#Save file to the disk
 saveRDS(computational_components_covid, "comp-comp_covid.rds")
 
comp_covid <- readRDS("comp-comp_covid.rds")
class(comp_covid)
#Making a listodnw object
library(listdown)
library(knitr)
ld_new <- listdown(load_cc_expr = readRDS("comp-comp_covid.rds"),
package = c("ggplot2", "tidyverse","scales"))

covidexample <- c(
 as.character(ld_rmarkdown_header("Covid plots",
author = "Leon",
 date = "2021")),
ld_make_chunks(ld_new))

library(DT)
library(rmarkdown)
library(knitr)
  writeLines(covidexample, "covid-example.Rmd")
  render("covid-example.Rmd",html_document())
  system("open covid-example.html")
```

## Covid with decorators
```{r}
#Add in data and decorators

ld_decorator <- listdown(load_cc_expr = readRDS("comp-comp_covid.rds"),
package = c("ggplot2", "tidyverse","scales", "plotly"),
decorator = list(ggplot = plot_ly))


coviddecoratorexample <- c(
  as.character(ld_rmarkdown_header("covid-example")),
          ld_make_chunks(ld_decorator))


 writeLines(coviddecoratorexample, "covid-decorator-example.Rmd")
  render("covid-decorator-example.Rmd",html_document())
  system("open covid-decorator-example.html")
```








## 2.2 Docorators for more complicated computational compontents











#MoreComplicated example
In the previous example, the _ggplot_ contains both the plotting mechanism for the scatter plots and the actual plots stored as list type objects. In the following example, we have used another set of data from the _survminer_ package. The original data was added into the document, and are presented in the form of data tables, that is, a type of decorator for the data. 

The _rld_ function shows a general syntax for rendering a listdown file into a html document. The header like the previous example can be added seperately. 
```{r}
rld <- function(ld) {
  writeLines(ld_make_chunks(ld), "doc.Rmd")
  render("doc.Rmd",html_document())
  system("open doc.html")
}
```

The 

```{r}
#survival example:
library(listdown)
library(gtsummary)
library(flextable)
library(dplyr)
library(survival)
library(survminer)
library(rmarkdown)
library(plotly)
library(ggplot2)
library(DT)

make_surv_cc <- function(trial, treat, surv_cond_chars) {
  table_1 <- trial %>%
    tbl_summary(by = all_of(treat))  %>%
    gtsummary::as_flextable()
  scs <- lapply(c("1", surv_cond_chars),
                function(sc) {
                  sprintf("Surv(ttdeath, death) ~ %s + %s", treat, sc) %>%
                    as.formula() %>%
                    surv_fit(trial) %>%
                    ggsurvplot()
                })
  
  

  
  
  names(scs) <- c("Overall", tools::toTitleCase(surv_cond_chars))
  list(`Table 1` = table_1, `Survival Plots` = scs, test = plot_ly(z=volcano, type="surface"))
}
surv_cc <- make_surv_cc(trial, treat = "trt",
                        surv_cond_chars = c("stage", "grade"))
ld_cc_dendro(surv_cc)
saveRDS(surv_cc, "surv-cc.rds")
ld_surv <- listdown(load_cc_expr = readRDS("surv-cc.rds"),
                    package = c("gtsummary", "flextable", "DT", 
                                "ggplot2", "plotly"),
                    decorator_chunk_opts = 
                      list(gg = list(fig.width = 8,
                                     fig.height = 6)),
                    decorator = list(data.frame = datatable),
                    echo = FALSE,
                    message = FALSE,
                    warning = FALSE,
                    fig.width = 7,
                    fig.height = 4.5)
rld(ld_surv)


```



```{css, echo = FALSE}
<center> <h1>2 Interactive Graphics</h1> </center>
```

#trelliscopejs example
The decorators example has displayed the data despite the huge amount of data in the actual dataset. 

Now, by using trelliscopejs package, we are trying to fit multiple interactive plots in the listdown files as objects, further displaying after rendering into html. The following example shows how trelliscope works in R. 

We have used the data from package _gapminder_. There are 5 continents, and we plotted the Oceania one.
```{r}
library(ggplot2)
library(gapminder)
head(gapminder)
str(gapminder)
summary(gapminder$continent)
```



```{r}
#just oceania 
qplot(year, lifeExp, data = subset(gapminder, continent == "Oceania")) +
  facet_wrap(~ country + continent) + theme_bw()
```

Too much plots if we plot it stright away, the final layout is folded, hence the trelliscopejs package allows us to search plots via interactive interface. 
```{r}
qplot(year, lifeExp, data = gapminder) +
  xlim(1948, 2011) + ylim(10, 95) + theme_bw() +
  facet_wrap(~ country + continent)

#trelliscope instead of facet
library(trelliscopejs)
qplot(year, lifeExp, data = gapminder) +
  xlim(1948, 2011) + ylim(10, 95) + theme_bw() +
  facet_trelliscope(~ country + continent, nrow = 2, ncol = 7, width = 300)

```


same survminer data try using plotly
```{r}
yrlfexp <- gapminder[sample(nrow(gapminder), 500), ]
plot_ly(yrlfexp, x = yrlfexp$year, y = yrlfexp$lifeExp, 
        text = paste("continent: ", yrlfexp$continent),
        mode = "markers", color = yrlfexp$country, 
        size = yrlfexp$lifeExp)
```




#for fun
```{r}
library(networkD3)
data(MisLinks, MisNodes)
forceNetwork(Links = MisLinks, Nodes = MisNodes, Source = "source",
             Target = "target", Value = "value", NodeID = "name",
             Group = "group", opacity = 0.4)


```

















